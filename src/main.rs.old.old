use std::{thread::sleep, time::Duration};

use macroquad::{miniquad::window::screen_size, prelude::*, ui::widgets::Window, window};
use rand::RandomRange;

const RUNNING : bool = true;
const WIDTH : i32 = 1640;
const CELL_SIZE : f32 = 60.0;
const HEIGHT : i32 = 640;
const TITLE : &str = "game of life";
struct Cell{
    alive: bool,
    x: f32,
    y: f32,
    next_state: bool
        
}
impl Cell{

    fn new(x: f32, y:f32) -> Self{
        Cell{
           alive: false,
           x: x,
           y: y,
           next_state: false
        }
    }
    fn is_alive(&self) -> bool{
        self.alive
    }
    fn kill(&mut self){
        self.alive = false;
    } 
    fn revive(&mut self){
        self.alive = true;
    }
    fn coordinates(&self) -> (f32, f32){
        (self.x, self.y)
    }
    fn change_state(&mut self){
        self.alive != self.alive;
    } 
}

struct Grid{
    cells: Vec<Cell>
    
}
impl Grid{
     fn new() -> Self{
        let mut grid : Vec<Cell> = vec![];    
        let mut x : f32= 0.0;
        let mut cell = Cell{alive: false, x:0.0,y:0.0, next_state: false};
        while x < screen_width(){ 
        let mut y : f32 = 0.0;
            while y < screen_height(){
           let cell = Cell{
               alive: true,
               x : x,
               y : y,
               next_state: true
                };
             y += CELL_SIZE;
             grid.push(cell);
            }
            x += CELL_SIZE;

        }
        
        Grid { cells: grid }
     }
     //new mesaures screen size and creates a new grid, 
     //draw draws rectangles 
    fn draw(&self){
        
        for cell in &self.cells{
            match cell.alive{ 
            true => {
                // draw_rectangle_lines(cell.x, cell.y, CELL_SIZE, CELL_SIZE, 1.0, GRAY);
                draw_rectangle(cell.x, cell.y, CELL_SIZE - 0.5, CELL_SIZE -0.5, LIGHTGRAY);
            },
            false => {

            //    draw_rectangle(cell.x, cell.y, CELL_SIZE, CELL_SIZE, BLACK);
                draw_rectangle_lines(cell.x, cell.y, CELL_SIZE, CELL_SIZE, 1.0, GRAY);
            }
        }
    }}
    
    fn get_size(&self) -> i32{
        self.cells.len().try_into().unwrap()
    }
    fn get_cell_index(&mut self, index: usize) -> Option<&mut Cell>{
        Some(&mut self.cells[index])
    }
    fn get_cell_by_coordinates(&mut self, x:f32, y:f32) -> Option<&mut Cell >{
          return   self.cells.iter_mut().find(
                |cell| x >= cell.x && x < cell.x + CELL_SIZE &&
                y >= cell.y && y < cell.y + CELL_SIZE
            );

            
    }
        

    fn random_live(&mut self){
           let index = RandomRange::gen_range(0, self.get_size()); 
           let alive : bool = index / 2 == 0;
           if let Some(cell) = self.get_cell_index(index.try_into().unwrap()){ 
           cell.kill();
           }

           
    }
    fn change(&mut self,x: f32, y:f32){
           if let Some(cell) = self.get_cell_by_coordinates(x,y){ 
            if cell.alive == false{
                cell.revive();
            }else {
                cell.kill();
            }
           }else {
               ()
           }
           
    }
    //where we at  right now is im tyring to figure out a way to count neighbours
    //at the moment im just seeing how this function could work by iterating over the grid and then
    //looping over all living cells, then killing their neighbouring cells
    fn count_neighbour(&mut self, ) -> u8{
        //TODO
        let mut result : u8 = 0;
        let mut neighbour_cells : Vec<(f32,f32)>= vec![];
        let mut counter = 0;
        let mut temp_cell = Cell::new(0.0, 0.0);
        //given all cells in the grid 
        //loop over all of them
        //for every cell -> pass it to get_neighbour_coordinates it will return the coordinates of
        //the current cell neighbours 
        //then loop over the cells in the returned coordinates 
        //change cell change() state based on living neighbour count
        while counter < self.cells.len(){
            let cell = &self.cells[counter];
            dbg!("alive :", cell.alive); 
            if cell.alive == false{ 
            let xy = &self.get_neighbour_coordinates(cell.x, cell.y);
            if !xy.is_empty(){ 
            self.change(xy[0].0, xy[0].1);
            }
            break;
             }
            counter +=1;
        }
       //for these coordinates  
        8
    // -> cell -> is dead? yes -> 
} 
    fn get_neighbour_coordinates(&mut self, x: f32, y:f32) -> Vec<(f32,f32)>{
        let mut counter = 8;
        let mut neighbour_cells : Vec<(f32,f32)> = vec![];
        //neighbour to the right
        if let Some(n1) = self.get_cell_by_coordinates(x + CELL_SIZE, y ){
            neighbour_cells.push(n1.coordinates());
        }else{
            dbg!("NOT FOUND!");
        }
        if let Some(n2) = self.get_cell_by_coordinates(x, y + CELL_SIZE){
            neighbour_cells.push(n2.coordinates());
        }else{
            dbg!("NOT FOUND Y!");
        }
        neighbour_cells
    }
    fn update_grid(&mut self){
        let mut counter = 0;
        let len = self.cells.len();
        for i in 0..len{
           
            let (x,y, next_state, alive) = {
                let cell = &self.cells[i];
                (cell.x, cell.y, cell.next_state, cell.alive)
            };
            if next_state != alive{
                self.change_nstate(x, y);
            }

            counter += 1;
        }
        self.draw();
    }
    
    fn change_nstate(&mut self, x:f32, y:f32){
            if let Some(cell) = self.get_cell_by_coordinates(x, y){
                cell.change_state();
            }
            else{
                dbg!("CANNOT CHANGE STATE!");
            }
    }
}


#[macroquad::main("gameoflife")]
async fn main() {
    let mut started : bool = false;
    let mut g = Grid::new();
    while RUNNING == true{
        clear_background(DARKBROWN);
        g.update_grid();
        if is_key_pressed(KeyCode::Space){
            g.random_live();
            g.count_neighbour();
            if started == false{
            //begin simulation
            started = true;
            }
        }

        if is_mouse_button_pressed(MouseButton::Left){
            let pos = mouse_position();
            g.change(pos.0, pos.1);
            g.count_neighbour();
        }
        next_frame().await;
    }
}




fn determine_cell_size(){
    //TODO:hdhsah
}
